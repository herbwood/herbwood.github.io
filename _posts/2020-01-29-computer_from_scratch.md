---
layout: post
title:  "[Book] 밑바닥부터 만드는 컴퓨팅 시스템 책 리뷰"
subtitle:   "computer from scratch"
categories: study
tags: books
comments: true
use_math : true
---

&nbsp;&nbsp;&nbsp;&nbsp;과거 대학교에서 '객체 지향 프로그래밍' 강의를 수강하여 C++ 언어와 객체 지향 프로그래밍 개념에 대해 배웠습니다. 당시 비전공자인 제가 듣기에 수업의 난이도가 높았을 뿐더러 수업 내용 자체가 지루하게 느껴졌습니다. 하지만 포인터 변수에 대한 개념이 등장하면서부터 수업에 대한 흥미가 생겼습니다. 변수의 주소를 할당받아 메모리에 빠르게 접근하는 방식은 색다르게 다가왔습니다. 그전까지는 코드를 짤 때 메모리나 반환 시간 등을 한번도 고려한 적이 없었기 때문입니다. 이 수업을 수강하면서 프로그램의 성능은 단순히 원하는 값을 반환하는 '정확성'뿐만 아니라 반환 속도나 메모리 사용량 등을 의미하는 **'효율성'**에 의해서도 결정된다는 것을 알게 되었습니다. 이러한 프로그램의 '효율성'을 제대로 이해하기 위해서는 컴퓨터 구조에 대해 공부할 필요가 있다는 것을 느꼈고 관련 서적을 찾다가 [밑바닥부터 만드는 컴퓨팅 시스템](http://www.yes24.com/Product/Goods/71129079)이라는 책에 대해 알게 되었습니다. 

<p align="center">
![KakaoTalk_20200416_143009076 (Small)](https://user-images.githubusercontent.com/35513025/79627936-7dce8800-8177-11ea-94d9-290dc8cb3b27.jpg)
</p>

&nbsp;&nbsp;&nbsp;&nbsp;'밑바닥부터 만드는 컴퓨팅 시스템'은 불 논리부터 기계어, 어셈블러, 컴파일러, 운영체제까지 컴퓨터 구조의 밑바닥부터 가장 차근차근 올라가면서 각 계층의 구조와 작동원리에 대해 설명합니다. 흥미로운 점은 저자가 'Jack'이라는 언어를 사용하여 'Hack'이라는 단순한 성능을 제공하는 컴퓨터를 직접 구현한다는 점입니다. 1~5장은 컴퓨터의 하드웨어 계층을, 6~13장은 소프트웨어 계층에 대해 설명합니다.

<p align="center">
![KakaoTalk_20200416_143030570 (Small)](https://user-images.githubusercontent.com/35513025/79627951-92ab1b80-8177-11ea-8ae2-aeeee6f32c0a.jpg)
</p>


&nbsp;&nbsp;&nbsp;&nbsp;1장에서는 불 함수를 물리적으로 구현한 **불 게이트**에 대해 설명합니다.  NAND 게이트만으로 불 함수 전부를 정의할 수 있다는 점을 새로 알게 되었습니다. 2장에서는 불 게이트를 조합한 산술 논리 연산 장치인 **ALU** 의 구조와 작동 방식을 설명합니다. 3장에서는 앞서 살펴본 조합칩이 아닌 입력받은 데이터의 상태를 유지하거나 메모리로부터 데이터를 불러오는 **순차칩**의 구성요소와 각각의 기능에 대해 설명합니다. 컴퓨터 메모리의 접근 방식에 관심을 가졌던지라 3장을 가장 흥미롭게 읽었습니다. 데이터를 읽어들이는 명령이 클록이라는 전기적 신호와 데이터를 플립플롭이라는 순차 소자가 입력 받아 레지스터로 구성된 RAM으로부터 읽어오는 복잡한 과정을 수반하는 것을 알게 되었습니다. 

<p align="center">
![KakaoTalk_20200416_143056430 (Small)](https://user-images.githubusercontent.com/35513025/79627956-963ea280-8177-11ea-9712-1ea93ba7d4d5.jpg)
</p>

4장에서는 앞서 살펴본 조합칩과 순차칩을 조작하는 **기계어**에 대해 설명합니다. 기계어는 프로세스와 레지스터를 이용하여 메모리를 조작할 수 있도록 미리 정의된 규칙입니다. 5장에서는 **폰 노이먼 구조**를 통해 입출력 장치, 메모리, CPU를 거쳐 컴퓨터가 작동하는 과정을 상세하게 설명합니다. 이번 장 역시 일상적으로 컴퓨터를 조작하는 행위가 하드웨어에서 어떻게 작동하는지 상세히 설명하여 매우 흥미롭게 읽었습니다.  

<p align="center">
![KakaoTalk_20200416_143117854 (Small)](https://user-images.githubusercontent.com/35513025/79627961-9dfe4700-8177-11ea-8b5c-8d4a8d0bc484.jpg)
</p>

6장에서는 기계어를 코드로 나타낸 **어셈블리**와 어셈블리를 기계어로 변환하는 어셈블러에 대해 설명합니다. 7,8장에서는  컴파일된 고수준 언어를 중간어로 변환하는 **가상머신(Virtual Machine)**에 대해 살펴봤습니다. 일반적으로 고수준 언어를 기계어로 번역하기 위해서는 고수준 언어와 기계어의 특성에 따라 수많은 컴파일러가 생깁니다. 하지만 가상머신을 사용하면 하드웨어로부터 독립적인 환경을 제공하여 기계 종속성으로부터 분리하는 것이 가능해집니다. 고수준 언어는 가상머신을 통해 1차적으로 번역된 후, 번역된 중간어는 기계어로 2차적으로 번역됩니다. 가상머신은 스택을 사용하여 데이터와 명령을 pop, push을 수행함으로써 저장하고 불러들인다는 점이 흥미로웠습니다. 

<p align="center">
![KakaoTalk_20200416_143137606 (Small)](https://user-images.githubusercontent.com/35513025/79627962-a0f93780-8177-11ea-899f-1d44dccb1769.jpg)
</p>

9장에서는 Jack 언어를 통해 **고수준 언어**가 제공해야 하는 기능에 대해 설명했습니다. 10, 11장에서는 고수준 언어를 컴파일하는 과정에 대해 설명합니다. **컴파일러**는 고수준 언어를 1차적으로 구문 규칙에 맞추는 파싱 과정과 언어의 기본 요소로 분류하는 토큰화하는 구문 분석 과정을 거쳐 2차적으로 VM코드를 생성하는 과정을 거칩니다. 12장에서는 **운영체제**의 제공하는 기능과 Jack을 통해 이를 구현하는 과정에 대한 설명으로 책을 마무리합니다. 
  
<p align="center">
![KakaoTalk_20200416_143154028 (Small)](https://user-images.githubusercontent.com/35513025/79627974-b5d5cb00-8177-11ea-853b-328208c882bd.jpg)
</p>

&nbsp;&nbsp;&nbsp;&nbsp;이 책은 수많은 추상화 과정을 상대적으로 쉽게 설명했다는 점에서 충분히 읽을만하다고 생각합니다(물론 읽기 어려운 부분도 있습니다). 굉장히 단순한 연산 기능만 제공하는 컴퓨터의 구조가 이 정도로 복잡하다는 점과 각 계층이 이전 계층과 굉장히 효율적이고 밀접하게 연결되어 있다는 사실이 놀라웠습니다.  그동안 컴퓨터 과학에 대해 공부하면서 운영체제, 프로그래밍 언어 등 컴퓨터를 구성하는 각각의 요소에 대해 공부했지만 각각의 요소가 어떤 식으로 연결되고 소통하지는에 대해서는 잘 알지 못했습니다. 이 책을 읽음으로써 컴퓨터라는 거대한 숲을 조망할 수 있는 새로운 관점을 얻을 수 있었습니다. 고수준 언어, 특히 인터프리터 언어를 사용하면서 직관적인 편리성에 의존하여 컴퓨터가 실제로 어떤 식으로 작동하는지 간과했던 것 같습니다. 컴퓨터의 작동 원리를 살펴봄으로써 얻은 관점을 앞으로 개발자로서 성장하는데 큰 도움이 될 것이라고 생각합니다.
